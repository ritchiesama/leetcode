推荐练习工具: Regex Buddy  

# 规则  
 
## 1. 普通字符(1)  
字母, 数字, 汉字, 下划线, 以及没有特殊定义的标点符号, 都是"**普通字符**" .  
表达式中的普通字符, 在匹配一个字符串的时候, **匹配与之相同的一个字符**
  
- 简单的转义字符 

|表达式 |作用|
|  :----:  | ----  | 
|\n|代表(匹配,下同)换行符|  
|\t|制表符|  
|\\\  |代表\本身|  
|\\^, \\$,\\., \\(, \\), \\{, \\}, \\?, \\+, \\*, \\|, \\[, \\]|匹配这些(转义)字符本身|  

## 2. 标准字符集合 
  - 能够与'多种字符'匹配的表达式  
  - 注意区分大小写, **大写是相反的意思**
  
|表达式 |作用|
|  :----:  | ----  | 
|\d|任意**一个**数字, 0~9中的任意一个|
|\ddd|任意**三个**数|
|\D|**不匹配**0~9中任何一个数字(下同)|
|\w|任意一个**字母**, **数字**, **下划线** 也就是A~Z, a~z, \_中的任意一个|
|.|小数点可以匹配任意一个字符 如果要匹配包括"\n"在内的所有字符,一般用[\s\S]|

\* 注: \s 是匹配所有空白字符, \S是匹配非空白字符 中间有个被省略的 \||或

## 3. 自定义字符集合
  - []方括号匹配方式,能够匹配方括号中**任意一个**字符


|表达式 |作用|
|  :----:  | ----  | 
|[ab5@]|匹配"a"或"b"或"5"或"@"|
|[^abc]|匹配"a"."b"."c"**之外**的任意一个字符|
|[f-k]|匹配"f"\~"k"之间的任意一个字符|
|[^A-F0-3]|匹配"A"\~"F", "0"\~"3"之外的任意一个字符(中线不需要间隔)|

- 注意: 正则表达式的特殊符号, 如果**被包含**到[]中括号中, 则失去特殊意义.  ^ - 这两个符号除外(可以用\^ 或者 \- 来转义)
- 标准字符集合, 除小数点外, 如果**被包含**于中括号中[], 自定义字符集合将包含该集合 如[\d.\-+]将匹配 数字 小数点 - 

## 4. 量词(Quantifier)
- 修饰匹配次数的特殊符号

|表达式 |作用|
|  :----:  | ----  | 
|{n}|表达式重复n次(只修饰前一个符号,如果想修饰前多个表达式,可以把表达式用括号括起来)|
|{m,n}|表达式至少重复m次,最多n次|
|{m,}|表达式至少重复m次,|
|?|匹配表达式0次或1次, 相当于{0,1}|
|+|表达式至少出现1次,相当徐{1,}|
|\*|表达式不出现或出现任意次,相当于{0,}|

- 匹配中的**贪婪模式**(匹配的字符越多越好,默认) (当然需要在规则之内贪婪)
- 非贪婪模式(匹配次数越少越好, 在大括号后加问号,如 {m,n}? ,区别于匹配0,1次的表达式 )


## 5.字符边界
- 零宽  本组标记匹配的不是字符而是**位置**(字符串中不显示的位置), 符合某种条件的位置


|表达式 |作用|
|  :----:  | ----  | 
|^|与字符串开始的地方匹配|
|$|与字符串结束的地方匹配|
|\\b|匹配一个**单词边界**|

- \\b匹配这样一个位置:前面的字符和后面的字符不全是\w


## 正则表达式的匹配模式
- IGNORECASE忽略大小写模式  (case insensitive)
  - 匹配时忽略大小写  
  - 默认情况下正则表达式区分大小写  
- SINGLELINE单行模式 
  - 整个文本看做一个字符串,只有一个开头和一个结尾
  - 使小数点"." 可以匹配包括换行符(\\n)在内的任意字符

- MULTILINE多行模式 (^$ match at line breaks)
  - 每行都是一个字符串,都有开头和结尾
  - 在制定了MULTILINE之后, 如果需要仅匹配字符串开始和结束为止,可以使用\\A 和\\Z

## 选择符和分组

|表达式 |作用|
|  :----:  | ----  | 
|\|左右两边表达式之间"或"的关系,匹配左边或者右边|
|()捕获组|(1).在被修饰匹配次数的时候,括号中的表达式可以作为整体被修饰<br> (2).取匹配结果的时候, 括号中的表达式匹配到的内容可以被单独得到<br>(3).每一对括号会分配一个编号,使用()的捕获根据左括号的顺序,从1开始自动编号. 捕获元素编号为0的第一个捕获是有整个表达式模式匹配的文本|
|(\?\:Experssion)|一些表达式中, 不得不使用(), 但又不需要保存()中子表达式匹配的内容, 这时可以用非捕获组来抵消使用()带来的副作用|

### 反响引用(\\nnn)  
- 对每一对()给与一个编号, 使用()的捕获**根据左括号的顺序**从1开始自动编号  
- 通过反向引用,可以对分组已捕获的字符串进行引用  


## 预搜索(零宽断言\ 环视)  
- 只进行子表达式的匹配, 匹配内容不记入最终的匹配结果, 是零宽度
- 这个位置应该符合某个条件. 判断当前位置的前后字符, 是否符合制定的条件, 但不匹配前后的字符. **是对位置的匹配**
- 占有字符还是零宽度,是针对匹配的内容是否保存到最终的匹配结果中而言的
|表达式 |作用|
|  :----:  | ----  | 
|(?=exp)||
|(?<=exp)||
|(?!exp)||
|(?<!exp)||

例:[a-z]+(?=\d+) 匹配以数字结尾的单词,但是数字本身不计入结果


## 练习 
### 电话号码验证  
固话+电话  
(0\d{2,3}-\d{7,9})|(1[35789]\d{9})  
注意:正则表达式只能匹配形式, 具体号码是否有效无法得知

邮箱  
\w+@s[a-z0-9A-Z]+(\.[A-Za-z]{2,3}){1,2}

##JAVA中正则表达式  
```java
Pattern p = Pattern.compile("");

Matcher m = p.matcher("aasdfkjlhklj");

boolean yeaorno = m.matches();//尝试将整个字符序列与该模式匹配

boolean yeaorno = m.find();//该方法扫描输入的序列, 查找与该模式匹配的下一个子序列(指针保持)

System.out.println(yesorno);
```
